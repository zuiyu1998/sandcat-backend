# MongoDB 分片消息存储实现指南

本文档提供了在 IM 后端系统中实现基于时间和用户 ID 的混合分片消息存储的详细指南。

## 1. 概述

混合分片存储策略结合了时间分片和用户 ID 分片的优点，能够在大规模消息系统中提供更好的性能和可扩展性。主要特点：

- **时间分片**：按月分割消息集合，便于历史数据归档和查询优化
- **用户 ID 分片**：基于用户 ID 哈希值分散数据，避免热点问题
- **自动维护**：自动创建新分片、添加索引和清理过期数据

## 2. 实施步骤

### 2.1 配置更新

在 `config.yml` 中添加分片配置选项：

```yaml
db:
  mongodb:
    # ... 现有配置 ...
    # 启用分片消息存储
    use_sharding: true
    # 用户ID分片数量（默认为10）
    user_shards: 10
```

系统会根据这些配置自动选择适当的消息存储实现。

### 2.2 代码实现

已添加以下文件：

- `db/src/mongodb/sharded_message.rs`：实现了 `HybridShardedMsgBox` 类，提供基于时间和用户 ID 的混合分片存储
- `db/src/benchmarks/benchmark_sharding.rs`：性能测试工具，用于评估分片存储性能

关键接口实现：

- `HybridShardedMsgBox` 实现了 `MsgRecBoxRepo` 和 `MsgRecBoxCleaner` 接口
- 通过 `db::msg_rec_box_repo()` 和 `db::msg_rec_box_cleaner()` 工厂方法根据配置自动选择实现

### 2.3 数据迁移

从单一集合迁移到分片存储：

```bash
# 迁移脚本尚在开发中
cargo run --bin migrate_messages
```

迁移过程建议：

1. 先创建临时数据库用于测试迁移
2. 将现有消息按时间和用户ID重新分配到对应分片
3. 验证数据一致性后切换到新存储

### 2.4 性能测试

使用内置基准测试工具评估性能：

```bash
# 混合读写测试（7:3比例的单聊和群聊消息）
cargo run -p db --bin benchmark_sharding -- --mode mixed --count 50000

# 单聊消息测试
cargo run -p db --bin benchmark_sharding -- --mode single --count 100000

# 群聊消息测试
cargo run -p db --bin benchmark_sharding -- --mode group --count 20000

# 测试不同分片数量
cargo run -p db --bin benchmark_sharding -- --mode mixed --count 50000 --shards 20
```

## 3. 实现细节

### 3.1 集合命名策略

分片集合遵循以下命名模式：`msg_box_{YEAR}_{MONTH}_{USER_RANGE}`

例如：

- `msg_box_2023_05_1`：2023年5月的用户分片1的消息
- `msg_box_2023_06_7`：2023年6月的用户分片7的消息

系统会自动管理这些集合，包括预先创建未来3个月的集合。

### 3.2 分片策略

- **时间分片**：根据消息的 `send_time` 字段按月划分
- **用户分片**：根据 `receiver_id` 字段的哈希值取模决定，使用标准哈希函数获取分片号：

  ```rust
  fn get_user_range(&self, user_id: &str) -> u8 {
      let mut hasher = std::collections::hash_map::DefaultHasher::new();
      user_id.hash(&mut hasher);
      (hasher.finish() % self.user_shards as u64) as u8
  }
  ```

### 3.3 索引策略

每个分片集合创建以下索引：

```javascript
// 接收者ID和序列号的复合索引，用于高效查询用户消息
{ "receiver_id": 1, "seq": 1 }

// 发送时间索引，用于时间范围查询
{ "send_time": 1 }

// 发送者ID和发送序号的复合索引
{ "sender_id": 1, "send_seq": 1 }

// 服务器ID和接收者ID的复合索引，允许同一消息ID发送给多个接收者
{ "server_id": 1, "receiver_id": 1 }
```

### 3.4 查询策略

系统根据查询类型使用不同策略：

- **单用户查询**：直接定位到用户对应的分片集合
- **跨月查询**：并行查询最近3个月的集合
- **通过ID查询**：搜索活跃集合
- **群组消息**：处理发送者和所有接收者的副本，保持相同的 `server_id`

### 3.5 清理策略

系统定期清理过期消息：

```rust
impl MsgRecBoxCleaner for HybridShardedMsgBox {
    fn clean_receive_box(&self, period: i64, types: Vec<i32>) {
        // 执行定期清理，保留指定类型的消息
        // period: 保留期（天数）
        // types: 要保留的消息类型
        ...
    }
}
```

集合清理策略包括：

1. 删除过期消息，但保留特定类型的系统消息
2. 从跟踪列表中移除太旧的集合（超过保留期1个月以上）

## 4. 性能表现

基于基准测试结果，混合分片存储在各场景下表现如下：

- **单聊消息**：每秒处理约1300-1350条消息，平均每条消息处理时间约740微秒
- **群聊消息**：每秒处理约560-610条消息，平均每条消息处理时间约1640-1770微秒
- **混合负载**：每秒处理约950-990条消息，平均每条消息处理时间约1010-1050微秒

与单一集合相比，分片存储在高负载场景下吞吐量提升约30-50%，并显著降低了平均响应时间。

## 5. 监控和维护

### 5.1 监控指标

建议监控以下指标：

- 各分片集合的大小和文档数量
- 读写操作的延迟分布
- 索引使用情况和效率
- 每个用户分片的负载分布

### 5.2 定期维护

- 检查索引健康状况
- 监控存储使用情况
- 分析用户活跃度分布，考虑调整分片策略

## 6. 故障排除

常见问题及解决方案：

1. **查询超时**：检查索引是否正确创建，并考虑增加用户分片数量
2. **存储不均衡**：分析用户活跃度分布，可能需要调整哈希策略
3. **重复键错误**：检查客户端生成的消息ID是否唯一
4. **分片删除问题**：确保清理任务正常运行，检查数据保留策略

## 7. 未来优化方向

- 实现更智能的动态分片策略，根据负载自动调整
- 添加数据分析功能，以便优化分片参数
- 考虑实现热点用户特殊处理机制
- 提供更完善的数据迁移和管理工具
